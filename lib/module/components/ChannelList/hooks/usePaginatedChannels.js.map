{"version":3,"sources":["usePaginatedChannels.ts"],"names":["wait","ms","Promise","resolve","setTimeout","usePaginatedChannels","filters","options","sort","client","channels","setChannels","error","setError","hasNextPage","setHasNextPage","loadingChannels","setLoadingChannels","loadingNextPage","setLoadingNextPage","offset","setOffset","refreshing","setRefreshing","queryChannels","queryType","retryCount","newOptions","limit","MAX_QUERY_CHANNELS_LIMIT","channelQueryResponse","newChannels","length","console","warn","loadNextPage","undefined","refreshList","reloadList","status"],"mappings":";;;;;;;;;;;;;;;;;AAAA;;AAEA;;AAEA;;;;;;AAoBA,IAAMA,IAAI,GAAG,SAAPA,IAAO,CAACC,EAAD;AAAA,SACX,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAa;AACvBC,IAAAA,UAAU,CAACD,OAAD,EAAUF,EAAV,CAAV;AACD,GAFD,CADW;AAAA,CAAb;;AAeO,IAAMI,oBAAoB,GAAG,SAAvBA,oBAAuB,OAYN;AAAA,0BAH5BC,OAG4B;AAAA,MAH5BA,OAG4B,6BAHlB,EAGkB;AAAA,0BAF5BC,OAE4B;AAAA,MAF5BA,OAE4B,6BAFlB,EAEkB;AAAA,uBAD5BC,IAC4B;AAAA,MAD5BA,IAC4B,0BADrB,EACqB;;AAAA,wBACT,kCADS;AAAA,MACpBC,MADoB,mBACpBA,MADoB;;AAAA,kBAGI,qBAE9B,EAF8B,CAHJ;AAAA;AAAA,MAGrBC,QAHqB;AAAA,MAGXC,WAHW;;AAAA,mBAMF,qBAAS,KAAT,CANE;AAAA;AAAA,MAMrBC,KANqB;AAAA,MAMdC,QANc;;AAAA,mBAOU,qBAAS,IAAT,CAPV;AAAA;AAAA,MAOrBC,WAPqB;AAAA,MAORC,cAPQ;;AAAA,mBAQkB,qBAAS,KAAT,CARlB;AAAA;AAAA,MAQrBC,eARqB;AAAA,MAQJC,kBARI;;AAAA,mBASkB,qBAAS,KAAT,CATlB;AAAA;AAAA,MASrBC,eATqB;AAAA,MASJC,kBATI;;AAAA,oBAUA,qBAAS,CAAT,CAVA;AAAA;AAAA,MAUrBC,MAVqB;AAAA,MAUbC,SAVa;;AAAA,oBAWQ,qBAAS,KAAT,CAXR;AAAA;AAAA,MAWrBC,UAXqB;AAAA,MAWTC,aAXS;;AAa5B,MAAMC,aAAa;AAAA,gFAAG;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACpBC,cAAAA,SADoB,2DACR,EADQ;AAEpBC,cAAAA,UAFoB,2DAEP,CAFO;;AAAA,oBAIhBV,eAAe,IAAIE,eAAnB,IAAsCI,UAJtB;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAMpB,kBAAIG,SAAS,KAAK,QAAlB,EAA4B;AAC1BR,gBAAAA,kBAAkB,CAAC,IAAD,CAAlB;AACD,eAFD,MAEO,IAAIQ,SAAS,KAAK,SAAlB,EAA6B;AAClCF,gBAAAA,aAAa,CAAC,IAAD,CAAb;AACD,eAFM,MAEA,IAAI,CAACE,SAAL,EAAgB;AACrBN,gBAAAA,kBAAkB,CAAC,IAAD,CAAlB;AACD;;AAEKQ,cAAAA,UAdc;AAelBC,gBAAAA,KAAK,oBAAErB,OAAF,oBAAEA,OAAO,CAAEqB,KAAX,6BAAoBC,+BAfP;AAgBlBT,gBAAAA,MAAM,EAAEK,SAAS,KAAK,QAAd,GAAyB,CAAzB,GAA6BL;AAhBnB,iBAiBfb,OAjBe;AAAA;AAAA;AAAA,qBAqBiBE,MAAM,CAACe,aAAP,CACjClB,OADiC,EAEjCE,IAFiC,EAGjCmB,UAHiC,CArBjB;;AAAA;AAqBZG,cAAAA,oBArBY;;AA4BlB,kBAAIL,SAAS,KAAK,QAAlB,EAA4B;AAC1BM,gBAAAA,WAAW,GAAGD,oBAAd;AACD,eAFD,MAEO;AACLC,gBAAAA,WAAW,iDAAOrB,QAAP,uCAAoBoB,oBAApB,EAAX;AACD;;AAEDnB,cAAAA,WAAW,CAACoB,WAAD,CAAX;AACAhB,cAAAA,cAAc,CAACe,oBAAoB,CAACE,MAArB,IAA+BL,UAAU,CAACC,KAA3C,CAAd;AACAP,cAAAA,SAAS,CAACU,WAAW,CAACC,MAAb,CAAT;AApCkB;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,qBAsCZhC,IAAI,CAAC,IAAD,CAtCQ;;AAAA;AAAA,oBAwCd0B,UAAU,KAAK,CAxCD;AAAA;AAAA;AAAA;;AAyChBT,cAAAA,kBAAkB,CAAC,KAAD,CAAlB;AACAE,cAAAA,kBAAkB,CAAC,KAAD,CAAlB;AACAI,cAAAA,aAAa,CAAC,KAAD,CAAb;AACAU,cAAAA,OAAO,CAACC,IAAR;AA5CgB,+CA6CTrB,QAAQ,CAAC,IAAD,CA7CC;;AAAA;AAAA,+CAgDXW,aAAa,CAACC,SAAD,EAAYC,UAAU,GAAG,CAAzB,CAhDF;;AAAA;AAmDpBT,cAAAA,kBAAkB,CAAC,KAAD,CAAlB;AACAE,cAAAA,kBAAkB,CAAC,KAAD,CAAlB;AACAI,cAAAA,aAAa,CAAC,KAAD,CAAb;;AArDoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAH;;AAAA,oBAAbC,aAAa;AAAA;AAAA;AAAA,KAAnB;;AAwDA,MAAMW,YAAY,GAAGrB,WAAW,GAAGU,aAAH,GAAmBY,SAAnD;;AACA,MAAMC,WAAW,GAAG,SAAdA,WAAc;AAAA,WAAMb,aAAa,CAAC,SAAD,CAAnB;AAAA,GAApB;;AACA,MAAMc,UAAU,GAAG,SAAbA,UAAa;AAAA,WAAMd,aAAa,CAAC,QAAD,CAAnB;AAAA,GAAnB;;AAEA,wBAAU,YAAM;AACd,QAAIf,MAAJ,EAAY;AACV6B,MAAAA,UAAU;AACX;AACF,GAJD,EAIG,CAAChC,OAAD,CAJH;AAMA,SAAO;AACLI,IAAAA,QAAQ,EAARA,QADK;AAELI,IAAAA,WAAW,EAAXA,WAFK;AAGLqB,IAAAA,YAAY,EAAZA,YAHK;AAILE,IAAAA,WAAW,EAAXA,WAJK;AAKLC,IAAAA,UAAU,EAAVA,UALK;AAML3B,IAAAA,WAAW,EAAXA,WANK;AAOL4B,IAAAA,MAAM,EAAE;AACN3B,MAAAA,KAAK,EAALA,KADM;AAENI,MAAAA,eAAe,EAAfA,eAFM;AAGNE,MAAAA,eAAe,EAAfA,eAHM;AAINI,MAAAA,UAAU,EAAVA;AAJM;AAPH,GAAP;AAcD,CAzGM","sourcesContent":["import { useEffect, useState } from 'react';\n\nimport { MAX_QUERY_CHANNELS_LIMIT } from '../utils';\n\nimport { useChatContext } from '../../../contexts/chatContext/ChatContext';\n\nimport type {\n  Channel,\n  ChannelFilters,\n  ChannelOptions,\n  ChannelSort,\n} from 'stream-chat';\n\nimport type {\n  DefaultAttachmentType,\n  DefaultChannelType,\n  DefaultCommandType,\n  DefaultEventType,\n  DefaultMessageType,\n  DefaultReactionType,\n  DefaultUserType,\n  UnknownType,\n} from '../../../types/types';\n\nconst wait = (ms: number) =>\n  new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n\ntype Parameters<\n  Ch extends UnknownType = DefaultChannelType,\n  Co extends string = DefaultCommandType,\n  Us extends UnknownType = DefaultUserType\n> = {\n  filters: ChannelFilters<Ch, Co, Us>;\n  options: ChannelOptions;\n  sort: ChannelSort<Ch>;\n};\n\nexport const usePaginatedChannels = <\n  At extends UnknownType = DefaultAttachmentType,\n  Ch extends UnknownType = DefaultChannelType,\n  Co extends string = DefaultCommandType,\n  Ev extends UnknownType = DefaultEventType,\n  Me extends UnknownType = DefaultMessageType,\n  Re extends UnknownType = DefaultReactionType,\n  Us extends UnknownType = DefaultUserType\n>({\n  filters = {},\n  options = {},\n  sort = {},\n}: Parameters<Ch, Co, Us>) => {\n  const { client } = useChatContext<At, Ch, Co, Ev, Me, Re, Us>();\n\n  const [channels, setChannels] = useState<\n    Channel<At, Ch, Co, Ev, Me, Re, Us>[]\n  >([]);\n  const [error, setError] = useState(false);\n  const [hasNextPage, setHasNextPage] = useState(true);\n  const [loadingChannels, setLoadingChannels] = useState(false);\n  const [loadingNextPage, setLoadingNextPage] = useState(false);\n  const [offset, setOffset] = useState(0);\n  const [refreshing, setRefreshing] = useState(false);\n\n  const queryChannels = async (\n    queryType = '',\n    retryCount = 0,\n  ): Promise<void> => {\n    if (loadingChannels || loadingNextPage || refreshing) return;\n\n    if (queryType === 'reload') {\n      setLoadingChannels(true);\n    } else if (queryType === 'refresh') {\n      setRefreshing(true);\n    } else if (!queryType) {\n      setLoadingNextPage(true);\n    }\n\n    const newOptions = {\n      limit: options?.limit ?? MAX_QUERY_CHANNELS_LIMIT,\n      offset: queryType === 'reload' ? 0 : offset,\n      ...options,\n    };\n\n    try {\n      const channelQueryResponse = await client.queryChannels(\n        filters,\n        sort,\n        newOptions,\n      );\n\n      let newChannels;\n      if (queryType === 'reload') {\n        newChannels = channelQueryResponse;\n      } else {\n        newChannels = [...channels, ...channelQueryResponse];\n      }\n\n      setChannels(newChannels);\n      setHasNextPage(channelQueryResponse.length >= newOptions.limit);\n      setOffset(newChannels.length);\n    } catch (e) {\n      await wait(2000);\n\n      if (retryCount === 3) {\n        setLoadingChannels(false);\n        setLoadingNextPage(false);\n        setRefreshing(false);\n        console.warn(e);\n        return setError(true);\n      }\n\n      return queryChannels(queryType, retryCount + 1);\n    }\n\n    setLoadingChannels(false);\n    setLoadingNextPage(false);\n    setRefreshing(false);\n  };\n\n  const loadNextPage = hasNextPage ? queryChannels : undefined;\n  const refreshList = () => queryChannels('refresh');\n  const reloadList = () => queryChannels('reload');\n\n  useEffect(() => {\n    if (client) {\n      reloadList();\n    }\n  }, [filters]);\n\n  return {\n    channels,\n    hasNextPage,\n    loadNextPage,\n    refreshList,\n    reloadList,\n    setChannels,\n    status: {\n      error,\n      loadingChannels,\n      loadingNextPage,\n      refreshing,\n    },\n  };\n};\n"]}